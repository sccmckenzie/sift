---
output: github_document
editor_options: 
  chunk_output_type: console
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%",
  warning = FALSE,
  dev = 'svglite'
)
```

# sift

<!-- badges: start -->
<!-- badges: end -->

sift facilitates **intelligent** & **efficient** exploration of datasets.

``` r
# install.packages("devtools")
devtools::install_github("sccmckenzie/sift")
```

sift is designed to work seamlessly with tidyverse.

```{r message=FALSE}
library(tidyverse) # needed for below examples
library(sift)
```

### 1. `sift::sift()`
##### Imagine `dplyr::filter()` that includes neighboring observations.

Perhaps you remember the Utah monolith. The buzz surrounding its discovery (and disappearance) served as a welcome diversion from the otherwise upsetting twists and turns of 2020.

<a title="Patrickamackie2 (Patrick A. Mackie), CC BY-SA 4.0 &lt;https://creativecommons.org/licenses/by-sa/4.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Utah_Monolith.jpg"><img width="256" alt="Utah Monolith" src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b8/Utah_Monolith.jpg/512px-Utah_Monolith.jpg"></a>

Suppose we are asked: *what else was happening in the world around this time?*

Let's peruse the `nyt2020` dataset to refresh our memory.

```{r}
sift::nyt2020 %>% 
  head(10)
```

```{r}
nyt2020 %>% 
  filter(str_detect(headline, "Monolith")) %>% 
  glimpse()
```

The monolith story broke on 2020-11-24. Prior to writing this documentation, I certainly would not have remembered this happening in November specifically.

Let's take a peek at other headlines from ±2 days.

```{r}
nyt2020 %>% 
  filter(pub_date > "2020-11-22",
         pub_date < "2020-11-26") %>% 
  select(headline, abstract, pub_date)
```

Notice that it took **two steps** to achieve the above result. We first had to **find the date of the monolith story** then **perform a subsequent call to `filter()`**. This procedure would quickly become a nuisance after a few iterations.

`sift()` provides an interface to perform this exact process in **one step**.

```{r}
nyt2020 %>% 
  sift(pub_date, scope = 2, str_detect(headline, "Monolith")) %>% 
  select(headline, abstract, pub_date)
```

Under the hood, `sift()` passes `str_detect(headline, "Monolith")` to `dplyr::filter()`, then augments the filtered observations to include any rows falling in ±2 day window (specified by `pub_date` and `scope = 2`).

### 2. `sift::kluster()`
##### Imagine 1D K-means, except K is chosen automatically.

Consider the `faithful` dataset.

Density plot below clearly demonstrates there are **2** clusters of eruptions.

```{r echo = FALSE, fig.height=2}
ggplot(faithful, aes(eruptions)) +
  geom_density() +
  geom_rug() +
  theme_minimal()
```

Currently, these clusters are *implicit*, meaning we do not have a categorical variable associating each observation with a cluster. We could manually assign clusters by drawing a line at, say, 3.0.

`kluster` does this automatically - no extra inputs needed.

```{r}
k <- kluster(faithful$eruptions)
```


```{r echo = FALSE, fig.height=2}
faithful$k <- k

ggplot(faithful, aes(eruptions)) +
  geom_density() +
  geom_rug(aes(color = factor(k))) +
  theme_minimal() +
  scale_color_discrete(name = "k")
```


